<!-- vscode-markdown-toc -->
* 1. [图形学基础元素](#)
* 2. [webgl原理](#webgl)
* 3. [GSGL基础](#GSGL)
* 4. [webgl绘制点线面](#webgl-1)
	* 4.1. [绘制没有变量的固定点（const）：](#const)
	* 4.2. [绘制添加变量的多个点（attribute变量vec4类型）外联着色器:](#attributevec4:)
	* 4.3. [只能画点的webgl引擎:](#webgl:)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc --># 基础绘制
<br>
<br>
<br>

##  1. <a name=''></a>图形学基础元素
点线面（三角）  
点 vec4(0.0,0.0,0.0,1.0)

<br>
<br>
<br>

##  2. <a name='webgl'></a>WebGL 基础概念
WebGL不是完整的3D API，仅仅是一个光栅化引擎，只可以绘制出基础的点，线和三角形。
复杂任务需要通过js代码，组合使用点，线和三角形代替实现（类似流水线造积木）。

WebGL在电脑的GPU中运行。因此你需要使用能够在GPU上运行的代码。
这样的代码需要提供成对的方法。每对方法中一个叫顶点着色器，
另一个叫片断着色器，并且使用一种和C或C++类似的强类型的语言
[GLSL](webgl-shaders-and-glsl.html)。 (GL着色语言)。
每一对组合起来称作一个 *program*（着色程序）。

顶点着色器的作用是计算顶点的位置。根据计算出的一系列顶点位置，WebGL可以对点，
线和三角形在内的一些图元进行光栅化处理。当对这些图元进行光栅化处理时需要使用片断着色器方法。
片断着色器的作用是计算出当前绘制图元中每个像素的颜色值。

几乎整个WebGL API都是关于如何设置这些成对方法的状态值以及运行它们。
对于想要绘制的每一个对象，都需要先设置一系列状态值，然后通过调用
`gl.drawArrays` 或 `gl.drawElements` 运行一个着色方法对，使得你的着色器对能够在GPU上运行。

<br>
<br>
<br>

##  3. <a name='GSGL'></a>GSGL基础

GLSL：

* GLSL(OpenGL着色语言OpenGL Shading Language)是一门类C的强类型语言  

图形编程是CPU语言和GPU语言的混合：

* GSGL - [CPU 编译链接] -> GPU可执行程序  
* 数据 - [CPU 处理 ] - [CPU发送GPU接收  通过缓冲区传输到GPU硬件]- [GPU执行GPU可执行程序  处理] -> 屏幕显示

[cpu程序 编译链接]：cpu通过webgl api控制着色器代码编译链接  

[GPU可执行程序在GPU上 处理]：GPU可执行程序和GPU硬件综合负责数据处理和渲染功能（软解硬解），在GPU硬件上的渲染流程并不是一成不变的，GPU可识别的数据包含点位数据颜色纹理贴图等，其组织形式


部分交给GPU硬件处理,在图形管道(graphic pipeline)中直接可执行的OpenGL着色语言. 


数据在GPU中展示为屏幕像素是一种单向流式处理（向前渲染）的图形管道(graphic pipeline)，类似于一段不断加染色剂的水管，最终计算成果是屏幕上显示的像素<font size=3 color=#F00>CPU与GPU不是一个硬件，无法直接获取其返回值，也不存在传地址（参）的指针绑定，获取值的通常方法为屏幕取像素值！！！</font>（特殊情况未普及的新标准计算着色器待定）。


着色器有两种类型：

* 顶点着色器(Vertex Shader)-- 形状转换到真实的3D绘制坐标中  
* 片段着色器(Fragment Shader)-- 计算最终渲染的颜色和其他属性



GLSL是强类型语言, 并且内置很多数学公式用于计算向量和矩阵. 快速编写着色器非常复杂, 但创建一个简单的着色器并不难. （方便理解，我们可以将之当作<font size=3 color=#F00>一门特殊的解释型语言！</font>，其编译和链接交给js或其他cpu语言来实时控制）





这些方法对所需的任何数据都需要发送到GPU，这里有着色器获取数据的4种方法。

1. 属性（Attributes）和缓冲

   缓冲是发送到GPU的一些二进制数据序列，通常情况下缓冲数据包括位置，法向量，纹理坐标，顶点颜色值等。
   你可以存储任何数据。

   属性用来指明怎么从缓冲中获取所需数据并将它提供给顶点着色器。
   例如你可能在缓冲中用三个32位的浮点型数据存储一个位置值。
   对于一个确切的属性你需要告诉它从哪个缓冲中获取数据，获取什么类型的数据（三个32位的浮点数据），
   起始偏移值是多少，到下一个位置的字节数是多少。

   缓冲不是随意读取的。事实上顶点着色器运行的次数是一个指定的确切数字，
   每一次运行属性会从指定的缓冲中按照指定规则依次获取下一个值。

2. 全局变量（Uniforms）

   全局变量在着色程序运行前赋值，在运行过程中全局有效。

3. 纹理（Textures）

   纹理是一个数据序列，可以在着色程序运行中随意读取其中的数据。
   大多数情况存放的是图像数据，但是纹理仅仅是数据序列，
   你也可以随意存放除了颜色数据以外的其它数据。

4. 可变量（Varyings）

   可变量是一种顶点着色器给片断着色器传值的方式，依照渲染的图元是点，
   线还是三角形，顶点着色器中设置的可变量会在片断着色器运行中获取不同的插值。

<br>
<br>
<br>

##  4. <a name='webgl-1'></a>webgl绘制点线面


###  4.1. <a name='const'></a>绘制没有变量的固定点（const）：

<iframe height="300" style="width: 100%;" scrolling="no" title="WebGL教程-WebGL基础-0.1.基础绘制——webgl绘制点线面————0绘制没有变量的固定点（const）" src="https://codepen.io/itild/embed/YzYpogr?default-tab=html%2Cresult&editable=true&theme-id=light" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/itild/pen/YzYpogr">
  WebGL教程-WebGL基础-0.1.基础绘制——webgl绘制点线面————0绘制没有变量的固定点（const）</a> by lpp (<a href="https://codepen.io/itild">@itild</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

HTML+shader

```html
<html>
<head>
  <!-- 顶点着色器 -->
  <script type='x-shader/x-vertex' id='shader-vs'>
    void main(){
            gl_Position=vec4(0.0,0.0,0.0,1.0);
            gl_PointSize=10.0;
        }
    </script>
  <!-- 片段着色器 -->
  <script type='x-shader/x-fragment' id='shader-fs'>
    void main(){
            gl_FragColor=vec4(1.0,1.0,0.0,1.0);
        }
    </script>
</head>

<body>
  <canvas id='webgldom' width='300' height='200'></canvas>
</body>

</html>
```
JS调用WebGL api

```js
// 1.获取webgl
let canvas = document.getElementById("webgldom");
let gl = canvas.getContext("webgl");//WebGLRenderingContext对象 绘图上下文

// 2.清空屏幕
gl.clearColor(0.5, 0.5, 0.5, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

// 3.初始化着色器程序
let vs_source = document.getElementById("shader-vs").innerHTML,
  fs_source = document.getElementById("shader-fs").innerHTML;

// 创建顶点着色器对象
let vertexShader = gl.createShader(gl.VERTEX_SHADER);//创建空着色器对象  type gl.VERTEX_SHADER 顶点着色器
let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(vertexShader, vs_source);// 绑定资源
gl.shaderSource(fragmentShader, fs_source);

//************************ 编译 ************************
gl.compileShader(vertexShader);//编译顶点着色器
gl.compileShader(fragmentShader);//编译片元着色器

// 创建一个着色器程序
let glProgram = gl.createProgram();
// 添加组合
gl.attachShader(glProgram, vertexShader);// 顶点着色器对象添加到着色器程序
gl.attachShader(glProgram, fragmentShader);// 片元着色器对象添加到着色器程序

//************************ 链接 ************************
gl.linkProgram(glProgram);//把着色器程序链接！！成一个完整的程序
gl.useProgram(glProgram);// 使用这个完整的程序
// 4.绘制一个点
gl.drawArrays(gl.POINTS, 0, 1);

```
<!-- https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html -->
<br>
<br>
<br>

###  4.2. <a name='attributevec4:'></a>绘制添加变量的多个点（attribute变量vec4类型）外联着色器:
<br>
上一个例子是编译好的固定单点着色器程序，画多个点，首先需要给GPU提供多个顶点  

<font size=3 color=#F00>通信机制：</font>跨语言通信首先要有传输机制和类型对应,js与shader跨硬件和语言，为了解决这个问题，webgl 系统就建立了一个供js向shader传输的缓冲区存储数据（数据与负责显示的程序分离）

WebGL提供了<font size=3 color=#F00>缓冲区对象</font>（一个全局数组）来连续存放多个顶点的数据，然后使用drawArrays一次性画出来，要引入着色器变量才行。


<iframe height="300" style="width: 100%;" scrolling="no" title="WebGL教程-WebGL基础-0.1.基础绘制——webgl绘制点线面————1绘制添加变量的多个点（attribute变量vec4类型）_外联" src="https://codepen.io/itild/embed/KKZaKzx?default-tab=html%2Cresult&editable=true&theme-id=light" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/itild/pen/KKZaKzx">
  WebGL教程-WebGL基础-0.1.基础绘制——webgl绘制点线面————1绘制添加变量的多个点（attribute变量vec4类型）_外联</a> by lpp (<a href="https://codepen.io/itild">@itild</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

HTML
```html
<canvas id="webgldom" width="200" height="200"></canvas> 
```

JS调用WebGL api + shader

```js
// 顶点着色器代码(决定顶点在哪里，大小)
var VSHADER_SOURCE =
  //************************attribute vec4 a_Position********************************// 
  //vec4是GLSL中的一种数据类型，在这里表示GLSL的四维浮点数向量
  //默认值为(0.0,0.0,0.0,1.0)，表示(x,y,z,w)。当有字段缺失时，会填充对应的默认值。
  //js中 Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5]);
  //(0.0, 0.5,0.0,1.0)，(-0.5,-0.5,0.0,1.0)，(0.5, -0.5,0.0,1.0)
  "attribute vec4 a_Position;\n" +
  "void main() {\n" +
  "  gl_Position = a_Position;\n" + // 设置顶点的位置
  "  gl_PointSize = 10.0;\n" + // 设置顶点的大小
  "}\n";

// 片元着色器代码（给像素上色）
var FSHADER_SOURCE =
  "void main() {\n" +
  "  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n" + // 设置顶点的颜色
  "}\n";

// 1.获取webgl
let canvas = document.getElementById("webgldom");
let gl = canvas.getContext("webgl"); //WebGLRenderingContext对象 绘图上下文

// 2.清空屏幕
gl.clearColor(0.5, 0.5, 0.5, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

// 3.初始化着色器程序
let vertexShader = gl.createShader(gl.VERTEX_SHADER); //创建空着色器对象 type gl.VERTEX_SHADER 顶点着色器
gl.shaderSource(vertexShader, VSHADER_SOURCE); // 绑定资源
gl.compileShader(vertexShader); // 编译

let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); //创建空着色器对象 片元
gl.shaderSource(fragmentShader, FSHADER_SOURCE); // 绑定资源
gl.compileShader(fragmentShader); // 编译

// 创建一个着色器程序
let glProgram = gl.createProgram();
// 添加组合
gl.attachShader(glProgram, vertexShader); // 顶点着色器对象添加到着色器程序
gl.attachShader(glProgram, fragmentShader); // 片元着色器对象添加到着色器程序

//************************ 链接 ************************
gl.linkProgram(glProgram); //把着色器程序链接！！成一个完整的程序
gl.useProgram(glProgram); // 使用这个完整的程序

// *****************************************变量*************************
// 此处用到顶点缓冲区
let vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5]); // 三个点Float32 类型
// 画三个点
let n = 3;
// 创建一个缓存对象，用于存放顶点数据
let vertexBuffer = gl.createBuffer();
// 绑定缓存对象
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
// 把数据写到缓冲对象中
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
// 获取顶点着色器代码中的顶点变量
let a_Position = gl.getAttribLocation(glProgram, "a_Position");
// 设置变量获取数据规则
gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
// 允许变量从 ARRAY_BUFFER目标上绑定的缓冲区对象获取数据
gl.enableVertexAttribArray(a_Position);
// *****************************************end*************************

// 4.绘制n个点
gl.drawArrays(gl.POINTS, 0, n);


```


###  4.3. <a name='webgl:'></a>只能画点的webgl引擎:

<iframe height="300" style="width: 100%;" scrolling="no" title="WebGL教程-WebGL基础-0.1.基础绘制——webgl绘制点线面————2绘制添加变量的多个点（attribute变量vec4类型）_外联_封装" src="https://codepen.io/itild/embed/LYebymP?default-tab=html%2Cresult&editable=true&theme-id=light" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/itild/pen/LYebymP">
  WebGL教程-WebGL基础-0.1.基础绘制——webgl绘制点线面————2绘制添加变量的多个点（attribute变量vec4类型）_外联_封装</a> by lpp (<a href="https://codepen.io/itild">@itild</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

HTML
```html
<canvas id="webgldom" width="200" height="200"></canvas> 
```

JS调用WebGL api + shader

```js
/**
 * _ 私有属性和方法
 *
 * 无状态或纯pipe式处理 静态工具类
 */
class GLStart {
  constructor() {}

  /**
   * 编译shader代码
   * @param {*} gl
   * @param {*} type
   * @param {*} source
   *  const vertexShader = _loadShader(gl, gl.VERTEX_SHADER, vsSource);
   * @returns
   */
  static _loadShader(gl, type, source) {
    const shader = gl.createShader(type); // 创建着色器对象
    gl.shaderSource(shader, source); // 提供shader代码  绑定资源
    gl.compileShader(shader); // 编译 -> 生成着色器
    return shader;
  }

  /**
   * 初始化一个着色程序
   * @param {*} gl
   * @param {*} vsSource
   * @param {*} fsSource
   * @returns
   */
  static initShaderProgram(gl, vsSource, fsSource) {
    const vertexShader = this._loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = this._loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    // Create the shader program

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    return shaderProgram;
  }
}

// 顶点着色器代码(决定顶在哪里，大小)
let VSHADER_SOURCE =
  "attribute vec4 a_Position;\n" +
  "void main() {\n" +
  "  gl_Position = a_Position;\n" + // 设置顶点的位置
  "  gl_PointSize = 10.0;\n" + // 设置顶点的大小
  "}\n";

// 片元着色器代码（给像素上色）
let FSHADER_SOURCE =
  "void main() {\n" +
  "  gl_FragColor = vec4(1.0, 0.0, 0.0, 0.5);\n" + // 设置顶点的颜色
  "}\n";

// 1.获取webgl
let canvas = document.getElementById("webgldom");
let gl = canvas.getContext("webgl"); //WebGLRenderingContext对象 绘图上下文
// 2.清空屏幕
gl.clearColor(0.5, 0.5, 0.5, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

// 3.初始化着色器程序
let program = GLStart.initShaderProgram(gl, VSHADER_SOURCE, FSHADER_SOURCE);
gl.program = program;
gl.useProgram(program);
let n = initVertexBuffers(gl, [0.0, 0.5, -0.5, -0.5, 0.5, -0.5]);

// 画n个点
gl.drawArrays(gl.POINTS, 0, n);

function initVertexBuffers(gl, jsArray) {
  let vertices = new Float32Array(jsArray);

  let vertexBuffer = gl.createBuffer(); // 创建一个缓存对象，用于存放顶点数据
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); // 绑定缓存对象
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); // 把数据写到缓冲对象中
  let a_Position = gl.getAttribLocation(gl.program, "a_Position"); // 获取顶点着色器代码中的顶点变量
  gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); // 设置变量获取数据规则
  gl.enableVertexAttribArray(a_Position); // 允许变量从 ARRAY_BUFFER目标上绑定的缓冲区对象获取数据
  return vertices.length / 2; //返回顶点数量
}


```
